require 'json'

quantities = JSON.parse(File.binread('GenerateQuantities.json'))

def generate_common_quantity_members(quantities)
  quantities.each do |quantity|
    name = quantity['Name']
    symbol = quantity['Symbol']
    si_unit = quantity['SIUnit']

    precision = nil
    if name == 'Temperature'
      precision = 12
    end

    si_unit_param = si_unit.dup
    si_unit_param[0] = si_unit_param[0].downcase

    path = "#{name}.Generated.cs"
    File.open(path, 'wb') do |f|

      f.write("//------------------------------------------------------------------------------\r\n")
      f.write("// <auto-generated>\r\n")
      f.write("//   Generated by GenerateQuantities.rb. Do not modify!\r\n")
      f.write("// </auto-generated>\r\n")
      f.write("//------------------------------------------------------------------------------\r\n")
      f.write("using System;\r\n")
      f.write("using System.Globalization;\r\n")
      f.write("\r\n")
      f.write("namespace PemsReporter.Units\r\n")
      f.write("{\r\n")
      f.write("   public readonly partial struct #{name}\r\n")
      f.write("      : IQuantity<#{name}>\r\n")
      f.write("   {\r\n")
      f.write("      public #{name}( double #{si_unit_param} )\r\n")
      f.write("      {\r\n")
      f.write("         #{si_unit} = #{si_unit_param};\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static readonly #{name} Zero = new #{name}( 0.0 );\r\n")
      f.write("      public static readonly #{name} Invalid = new #{name}( double.NaN );\r\n")
      f.write("\r\n")
      f.write("      public double #{si_unit} { get; }\r\n")
      f.write("\r\n")
      f.write("      double IQuantity.RawValue => #{si_unit};\r\n")
      f.write("\r\n")
      f.write("      public override string ToString()\r\n")
      f.write("      {\r\n")
      f.write("         return string.Format(\r\n")
      f.write("            CultureInfo.InvariantCulture,\r\n")
      f.write("            \"{0} {1}\", #{si_unit}, \"#{symbol}\" );\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public override int GetHashCode()\r\n")
      f.write("      {\r\n")
      f.write("         return #{si_unit}.GetHashCode();\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public override bool Equals( object obj )\r\n")
      f.write("      {\r\n")
      f.write("         return obj is #{name} && Equals( (#{name})obj );\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public bool Equals( #{name} other )\r\n")
      f.write("      {\r\n")
      f.write("         return #{si_unit}.Equals( other.#{si_unit} );\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public int CompareTo( #{name} other )\r\n")
      f.write("      {\r\n")
      f.write("         if( #{si_unit} < other.#{si_unit} )\r\n")
      f.write("            return -1;\r\n")
      f.write("         if( #{si_unit} > other.#{si_unit} )\r\n")
      f.write("            return 1;\r\n")
      f.write("         return 0;\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public int CompareTo( object other )\r\n")
      f.write("      {\r\n")
      f.write("         if( other == null )\r\n")
      f.write("            return 1;\r\n")
      f.write("         if( !( other is #{name} ) )\r\n")
      f.write("            throw new ArgumentException( $\"Argument must be of type {nameof( #{name} )}.\" );\r\n")
      f.write("         return CompareTo( (#{name})other );\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static bool operator ==( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return lhs.#{si_unit} == rhs.#{si_unit};\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static bool operator !=( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return lhs.#{si_unit} != rhs.#{si_unit};\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static bool operator <( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return lhs.#{si_unit} < rhs.#{si_unit};\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static bool operator >( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return lhs.#{si_unit} > rhs.#{si_unit};\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static bool operator <=( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return lhs.#{si_unit} <= rhs.#{si_unit};\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static bool operator >=( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return lhs.#{si_unit} >= rhs.#{si_unit};\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static #{name} operator +( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return new #{name}( lhs.#{si_unit} + rhs.#{si_unit} );\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static #{name} operator -( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return new #{name}( lhs.#{si_unit} - rhs.#{si_unit} );\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static #{name} operator *( #{name} lhs, double rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return new #{name}( lhs.#{si_unit} * rhs );\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static #{name} operator *( double lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return new #{name}( lhs * rhs.#{si_unit} );\r\n")
      f.write("      }\r\n")
      f.write("\r\n")
      f.write("      public static double operator /( #{name} lhs, #{name} rhs )\r\n")
      f.write("      {\r\n")
      f.write("         return lhs.#{si_unit} / rhs.#{si_unit};\r\n")
      f.write("      }\r\n")
      f.write("   }\r\n")
      f.write("}\r\n")
    end

    puts path
  end
end

generate_common_quantity_members quantities
